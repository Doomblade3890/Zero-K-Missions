----------------------------------------------------------------------------------------------------------------------------------------------------------------function gadget:GetInfo()	return {		name = "King of the Hill (mod)",		desc = "obvious",		author = "Alchemist, Licho, KingRaptor",		date = "April 2009",		license = "Public domain",		layer = 1,		enabled = true	}end----------------------------------------------------------------------------------------------------------------------------------------------------------------local blockedDefs = {	[ UnitDefNames['terraunit'].id ] = true,	[ UnitDefNames['wolverine_mine'].id ] = true,}local hillPos = {4000, Spring.GetGroundHeight(4000, 4000), 4000}local hillRadius = 250----------------------------------------------------------------------------------------------------------------------------------------------------------------if(gadgetHandler:IsSyncedCode()) then----------------------------------------------------------------------------------SYNCED--------------------------------------------------------------------------------local spGetUnitsInCylinder	= Spring.GetUnitsInCylinderlocal spGetUnitTeam		= Spring.GetUnitTeamlocal spGetUnitAllyTeam		= Spring.GetUnitAllyTeamlocal spGetUnitDefID		= Spring.GetUnitDefID----------------------------------------------------------------------------------------------------------------------------------------------------------------local teams = {	[0] = 0,	[1] = 1,	[3] = 1}allyTeams = {	[0] = 0,	[1] = 0,}local UPDATE_PERIOD = 15local capturingAllyTeam = nillocal controllingAllyTeam = nillocal controlStrength = 0 	-- 0 to 1local captureSpeed = 0.05*(UPDATE_PERIOD/30)	-- 20 seconds to fully caplocal decaptureSpeed = 0.1*(UPDATE_PERIOD/30)	-- 10 seconds to fully uncaplocal grace = 0local graceLength = 0_G.allyTeams = allyTeams_G.capturingAllyTeam = capturingAllyTeam_G.controllingAllyTeam = controllingAllyTeam_G.controlStrength = controlStrength_G.grace = grace----------------------------------------------------------------------------------------------------------------------------------------------------------------local function GetSetCount(set)  local count = 0  for _ in pairs(set) do    count = count + 1  end  return countendlocal function GetTimeRemaining(allyTeam)	return allyTeams[allyTeam]endlocal function ProcessHill()	local soleAllyTeam	-- may not actually be the sole ally team	local contested = false	local present = {}		local units = spGetUnitsInCylinder(hillPos[1], hillPos[3], hillRadius)	for i=1,#units do		local unitID = units[i]		local team = spGetUnitTeam(unitID)		local allyTeam = spGetUnitAllyTeam(unitID)		local unitDefID = spGetUnitDefID(unitID)		if teams[team] and not blockedDefs[unitID] then			present[allyTeam] = true			soleAllyTeam = allyTeam		end	end		-- possible situations:	-- neutral, uncontested,	-- neutral, contested,	-- neutral, being captured	-- captured, uncontested	-- captured, contested	-- captured, being decaptured		local numAllyTeams = GetSetCount(present)		if not controllingAllyTeam then	-- neutral		if numAllyTeams == 0 and capturingAllyTeam then	-- unoccupied			-- bleed current progress			controlStrength = controlStrength - captureSpeed			if controlStrength <= 0 then				capturingAllyTeam = nil				controlStrength = 0			end		elseif numAllyTeams == 1 then	-- occupied by one team			if soleAllyTeam ~= capturingAllyTeam then	-- decapture				controlStrength = controlStrength - decaptureSpeed				if controlStrength <= 0 then					capturingAllyTeam = soleAllyTeam					controlStrength = 0				end			else	-- capture				controlStrength = controlStrength + captureSpeed				if controlStrength >= 1 then					controllingAllyTeam = soleAllyTeam					controlStrength = 1					capturingAllyTeam = nil				end			end		else	-- contested			-- do nothing?		end	else	-- controlled by one allyTeam		if numAllyTeams == 0 then	-- unoccupied			-- recover to full if necessary			controlStrength = controlStrength + captureSpeed			if controlStrength >= 1 then				controlStrength = 1				capturingAllyTeam = nil			end		elseif numAllyTeams == 1 then	-- occupied by one team			if soleAllyTeam ~= controllingAllyTeam then	-- decapture				controlStrength = controlStrength - decaptureSpeed				if controlStrength <= 0 then					controllingAllyTeam = nil					capturingAllyTeam = soleAllyTeam					controlStrength = 0				end			else	-- recover to full if necessary (at increased speed)				controlStrength = controlStrength + decaptureSpeed				if controlStrength >= 1 then					controlStrength = 1					capturingAllyTeam = nil				end			end		else	-- contested			-- do nothing?		end	end		if controllingAllyTeam then		allyTeams[controllingAllyTeam] = allyTeams[controllingAllyTeam] - (UPDATE_PERIOD/30)		if allyTeams[controllingAllyTeam] <= 0 then			if controllingAllyTeam == 0 then				GG.mission.ExecuteTriggerByName("Victory")			else				GG.mission.ExecuteTriggerByName("Defeat")			end			gadgetHandler:RemoveGadget()		end	end		_G.capturingAllyTeam = capturingAllyTeam	_G.controllingAllyTeam = controllingAllyTeam	_G.controlStrength = controlStrengthend----------------------------------------------------------------------------------------------------------------------------------------------------------------function gadget:Initialize()	local goalTime = (Spring.GetModOptions().hilltime or 0) * 60	graceLength = Spring.GetModOptions().gracetime	if graceLength then		grace = graceLength * 60	else		grace = 0	end	for allyTeamID in pairs(allyTeams) do		allyTeams[allyTeamID] = goalTime	end		GG.KotH = GG.KotH or {}	GG.KotH.GetTimeRemaining = GetTimeRemainingendfunction gadget:GameFrame(f)	if(f%30 == 0 and f < grace * 30 + graceLength*30*60) then		grace = grace - 1		_G.grace = grace	end	if(f == grace*30 + graceLength*30*60) then		_G.grace = grace		--Spring.Echo("Grace period is over. GET THE HILL!")	end	if(f % UPDATE_PERIOD == 0) then		ProcessHill()	endend----------------------------------------------------------------------------------------------------------------------------------------------------------------else----------------------------------------------------------------------------------UNSYNCED--------------------------------------------------------------------------------local glBeginEnd = gl.BeginEndlocal glPushMatrix = gl.PushMatrixlocal glPopMatrix = gl.PopMatrixlocal glColor = gl.Colorlocal glTranslate = gl.Translatelocal glVertex = gl.Vertexlocal glText = gl.Textlocal allyTeams = { [0] = {0,0,1}, [1] = {1,0,0} }local circleDivs = 65	-- circle resolutionlocal innersize = 0.8local outersize = 1 -- outer radius size compared to hill radius-- explanation for string.char: http://springrts.com/phpbb/viewtopic.php?f=23&t=24952local function GetColorChar(colorArg)	local color = {}	for i=1,3 do		color[i] = math.floor(colorArg[i] * 255)	end	return string.char(255,color[1],color[2],color[3])endlocal function DrawHillCircle(owner, capper)	local innerColor = {1,1,1}	if owner then		innerColor = allyTeams[owner]	end	local r1, g1, b1 = unpack(innerColor)	local outerColor = innerColor	if capper and (not owner) then		outerColor = allyTeams[capper]	end	local r2, g2, b2 = unpack(outerColor)		local alpha = 0.5	local fadealpha = 0.3	if (r == b) and (r == g) then  -- increased alphas for greys/b/w		alpha = 0.7		fadealpha = 0.5	end	local radius = hillRadius		glPushMatrix()	glTranslate(hillPos[1], hillPos[2], hillPos[3])		local numSlices = math.floor(SYNCED.controlStrength*circleDivs)	glBeginEnd(GL.TRIANGLES, function()		local radstep = (2.0 * math.pi) / circleDivs		for i = 1, circleDivs do			local a1 = (i * radstep)			local a2 = ((i+1) * radstep)			glColor(r1, g1, b1, 0)			glVertex(0, 0, 0)			glColor(r1, g1, b1, fadealpha)			glVertex(math.sin(a1)*radius, 0, math.cos(a1)*radius)			glVertex(math.sin(a2)*radius, 0, math.cos(a2)*radius)		end	end)	glBeginEnd(GL.QUADS, function()		local radstep = (2.0 * math.pi) / circleDivs		for i = 1, numSlices do			local a1 = (i * radstep)			local a2 = ((i+1) * radstep)			glColor(r2, g2, b2, fadealpha)			glVertex(math.sin(a1)* radius * innersize, 0, math.cos(a1)*radius * innersize)			glVertex(math.sin(a2)* radius * innersize, 0, math.cos(a2)*radius * innersize)			glColor(r2, g2, b2, alpha)			glVertex(math.sin(a2) * radius * outersize, 0, math.cos(a2) * radius * outersize)			glVertex(math.sin(a1) * radius * outersize, 0, math.cos(a1) * radius * outersize)		end	end)	glPopMatrix()endfunction gadget:DrawWorldPreUnit()	local owner = SYNCED.controllingAllyTeam	local capper = SYNCED.capturingAllyTeam	DrawHillCircle(owner, capper)endfunction gadget:DrawScreen()	local vsx, vsy = gl.GetViewSizes()	local posx = vsx * 0.5	local grace = SYNCED.grace	if (grace > 0) then		local posy = vsy * 0.75		if (grace % 60 < 10) then			glText("Grace period over in " .. math.floor(grace/60) .. ":0" .. math.floor(grace%60), posx, posy, 14, "ocn")		else			glText("Grace period over in " .. math.floor(grace/60) .. ":" .. math.floor(grace%60), posx, posy, 14, "ocn")		end	end		posx = posx - 96	local posy = vsy * 0.25	for allyTeamID, color in pairs(allyTeams) do		posx = posx + 64		local timeLeft = SYNCED.allyTeams[allyTeamID]		if(timeLeft % 60 < 10) then			glText(GetColorChar(color) .. math.floor(timeLeft/60) .. ":0" .. math.floor(timeLeft%60), posx, posy, 18, "ocn")		else			glText(GetColorChar(color) .. math.floor(timeLeft/60) .. ":" .. math.floor(timeLeft%60), posx, posy, 18, "ocn")		end	endendend--------------------------------------------------------------------------------